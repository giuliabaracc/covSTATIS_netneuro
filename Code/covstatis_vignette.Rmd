---
title: "covSTATIS vignette"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
library(tidyr)
library(dplyr)
library(osfr)
library(readr)
library(DistatisR)  # covSTATIS analysis
library(PTCA4CATA)  # factor map plotting
library(ExPosition) # makeDataNominal()
library(gplots)     # heatmap.2()
library(sp)         # convex hulls 
library(ggplot2)
```

# Setup & data info

Retrieve data from our Github. Download nback (0-,1-,2-back) data from: https://osf.io/hnj7s/. You should have 144x3 txt files (nx3 task conditions). Make sure to download the following csv file "participants_ages.csv" as well from: https://osf.io/dm23b/. Make sure txt files, participant info and the atlas labels csv files are stored in the Data folder. 

After standard preprocessing (see Rieck et al., 2022 NboA), each individualâ€™s voxel-time series were parcellated, for each task condition, using the standard 100 region-17 network Schaefer atlas (CITE). For each participant and condition, product-to-moment correlations were quantified between region pairs, to ultimately obtain 100x100x3 functional connectivity matrices for each individual. These 144x100x100x3 data tables (individual x region x region x task condition) are used in this tutorial.

## Read in the data

The first step is to read in our connectivity matrices to form a 3D array (= 'X' here below) for analysis with covSTATIS. In this vignette the 3D array dimensionality is 100 x 100 x 144 (ROI x ROI x N participants) per task condition (3 in total). 

```{r}
setwd('./../Data/')
atlas_prefix <- "Schaefer100_17"
atlas_labels <- read_csv('Schaefer_100parcel_17network_labels.csv')
demog_in <- read_csv('participant_ages.csv')
ids <- demog_in$subjectID

## Read in FC .txt files and reshape into 3D array with size n_roi x n_roi x n_sub*n_conditions (i.e. n_fns)
all_fns<-list.files(pattern = paste0('^',atlas_prefix, '.*txt'))
X_list<-lapply(X=all_fns, FUN=read_delim, delim="\t", col_names = F,col_type = list(.default = col_double()))
X <- array(unlist(X_list), c(dim(X_list[[1]]), length(X_list)))
rm(X_list)

#### For Schaefer atlases, label the individual ROIs
## Label rows and columns with ROI label
if(length(grep("Schaefer", atlas_prefix)>0)){
  rownames(X)<- atlas_labels$ROI_label
  colnames(X)<- atlas_labels$ROI_label
}

## Label 3rd dimension with subject and task information (modified from filenames)
dimnames(X)[[3]]<-all_fns %>% gsub(pattern=".txt", replacement = "") %>%
  gsub(pattern=paste0(atlas_prefix,"_"), replacement = "")

```

The resulting X data cube is `r dim(X)[1]` by `r dim(X)[2]` ROIs across `r dim(X)[3]/3` participants with 3 n-back conditions each. 

# Run covSTATIS

Now that we have created our 3D data array (X), we can run covSTATIS. Since we are dealing with correlation values, the Distance flag should be set to FALSE. The nfact2keep flag denotes the number of components we want to keep (the bigger the value, the slower the computations).

The Scree plot shows how much variance is explained by each component/dimension of covSTATIS. Ideally, there will be one strong component (as is the case with these data) indicating a strong coherence in the general network organization across all participants.

```{r}
covstatis_res <- distatis(X, Distance = F,nfact2keep = 10,compact = F)

PlotScree(ev = covstatis_res$res4Cmat$eigValues, 
          title = "RV-map: Explained Variance per Dimension")
```

# Visualizing the results

## Compromise heatmap

Let's now reconstruct a heatmap to explore our covSTATIS output. Let's start by visualizing the first two components (LV1, LV2).

```{r}
covstatis_corrmat_lv1_lv2 <- tcrossprod(covstatis_res$res4Splus$F[,c(1,2)])

heatmap.2(covstatis_corrmat_lv1_lv2, 
          Rowv=F, Colv = "Rowv",dendrogram = "none",trace="none",
          scale="none", breaks=seq(-.03,.03,length.out = 100), col = redblue(99),
          main= 'Rebuilt Heatmap for LV1 and LV2',
          na.color = "darkgray",
          colRow=atlas_labels$Network_color, colCol=atlas_labels$Network_color)
```

## Compromise space plotting

Let's now plot the linear combination of all our data tables, the compromise space. The compromise space shows us how regional connectivity values relate to each other across individuals and conditions. Each point in the compromise space represents a different ROI from our functional connectivity matrices, colored by their network membership. The closer points are, the stronger the functional connectivity across the entire dataset.

```{r}
network_labels <- unique(atlas_labels$Network)
network_colors <- unique(atlas_labels$Network_color)

# To get graphs with axes 1 and 2:
h_axis <-1 # component to plot on x-axis
v_axis <-2 # component to plot on y-axis

compromise_graph_out <- createFactorMap(covstatis_res$res4Splus$F,
                                        axis1 = h_axis, axis2 = v_axis,
                                        title = 'Compromise ROI Space',
                                        col.points = atlas_labels$Network_color,
                                        alpha.points=.6, cex=3) 
print(compromise_graph_out$zeMap_background + compromise_graph_out$zeMap_dots)
```

We can also compute the average of all the ROIs (i.e., barycenter) for each _a priori_ network to get a coarser network compromise map.

```{r}
network_mean_F <- t(apply(makeNominalData(as.matrix(atlas_labels$Network)),2,function(x){x/sum(x)})) %*% covstatis_res$res4Splus$F
row.names(network_mean_F) <- network_labels

compromise_network_graph_out <- createFactorMap(network_mean_F,
                                                axis1 = h_axis,axis2 = v_axis, 
                                                title = "Compromise map for network-level barycenters",
                                                col.points = network_colors, col.labels = network_colors,
                                                alpha.points=.8, cex=5, text.cex=4, alpha.labels=.8, pch=18)
print(compromise_network_graph_out$zeMap + compromise_network_graph_out$zeMap_dots)
```

Both the ROI-level and network-level factor maps can be overlaid to show how individuals ROIs cluster around their respective networks, for the whole group.

```{r}
print(compromise_graph_out$zeMap_background + compromise_graph_out$zeMap_dots + 
        compromise_network_graph_out$zeMap_dots + compromise_network_graph_out$zeMap_text)
```

## Partial maps on the compromise

Using partial projection, we can now project each condition back onto the compromise space (i.e., partial factor scores) to understand how each correlation matrix fits in the compromise (or group level) space. 
To do that, we should first create a design matrix specifying which slice in our X cube corresponds to which n-back condition:

```{r}
condition_design <- vector("character",dim(X)[3])
condition_design[grep("*_nbk_0b",dimnames(X)[[3]])]<-"0b"
condition_design[grep("*_nbk_1b",dimnames(X)[[3]])]<-"1b"
condition_design[grep("*_nbk_2b",dimnames(X)[[3]])]<-"2b"
```

Now we can compute and plot the partial maps for the different n-back conditions, for each ROI. This plot shows how much the connectivity for each ROI is similar/different across task conditions (closer to the ROI center: more similar; farther from ROI center: more different). 

```{r}
#Compute the Partial map
F_j     <- covstatis_res$res4Splus$PartialF
alpha_j <- covstatis_res$res4Cmat$alpha
# create the groups based on design
code4Groups <- unique(condition_design)

nK <- length(code4Groups)
# initialize F_K and alpha_k
F_k <- array(0, dim = c(dim(F_j)[[1]], dim(F_j)[[2]],nK))
dimnames(F_k) <- list(dimnames(F_j)[[1]], 
                      dimnames(F_j)[[2]], code4Groups)
alpha_k <- rep(0, nK)
names(alpha_k) <- code4Groups
Fa_j <- F_j
for (j in 1:dim(F_j)[[3]]){ Fa_j[,,j]  <- F_j[,,j] * alpha_j[j] }
for (k in 1:nK){
  lindex <- condition_design == code4Groups[k]
  alpha_k[k] <- sum(alpha_j[lindex])
  F_k[,,k] <- (1/alpha_k[k])*apply(Fa_j[,,lindex],c(1,2),sum)
}

compromise_pfs <- createPartialFactorScoresMap(
  factorScores = covstatis_res$res4Splus$F,      
  partialFactorScores = F_k,  
  axis1 = 1, axis2 = 2,
  colors4Items = as.vector(atlas_labels$Network_color), 
  colors4Blocks = c("yellowgreen", "olivedrab", "darkgreen"),
  names4Partial = dimnames(F_k)[[3]], # 
  shape.points = 20)

print(compromise_graph_out$zeMap_background + compromise_graph_out$zeMap_dots +
  compromise_pfs$mapColByBlocks + ggtitle('Compromise map - Partial factor scores by task design'))
```

That's a very busy plot! Let's clean it up to make things easier to interpret. Now we'll compute the partial factor scores by the mean network compromise. Similar to our ROI plot, for each network, the more spread out the conditions are from the network mean, the more diverse the functional connectivity is across task conditions.

```{r}
F_k_network<-array(NA, dim=c(length(network_labels), dim(F_k)[2], dim(F_k)[3]))
dimnames(F_k_network)<-list(network_labels, dimnames(F_k)[[2]], dimnames(F_k)[[3]])

for(i in 1:dim(F_k_network)[3]){
  F_k_network[,,i]<- t(apply(makeNominalData(as.matrix(atlas_labels$Network)),2,function(x){x/sum(x)})) %*% F_k[,,i]
}

compromise_pfs_network <- createPartialFactorScoresMap(
  factorScores = network_mean_F,      
  partialFactorScores = F_k_network,  
  axis1 = 1, axis2 = 2,
  colors4Items = network_colors, 
  colors4Blocks = c("yellowgreen", "olivedrab", "darkgreen"),
  names4Partial = dimnames(F_k_network)[[3]], # 
  size.labels=3.5, size.points = 2,shape.points=20)

print(compromise_network_graph_out$zeMap + compromise_pfs_network$mapColByBlocks + ggtitle('Network level compromise map - Partial factor scores by task design'))
```

We can now compute the area of the convex hull around the partial factor scores for each individual at the network-level (NB: this can be done at the regional level too). Area of the hull scores can be seen as "task condition differentiation scores": the larger the area of the hull, the more diverse the network functional connectivity is across task conditions (more distant from mean); the smaller the area of the hull, the more homogenous the functional connectivity across 0-,1-, and 2-back.

```{r}
## Create empty matrix to put results in, should be # participants (rows) by # networks (columns)
task_diff_network_level <-data.frame(matrix(0, length(ids),length(network_labels)))
rownames(task_diff_network_level) <- ids
names(task_diff_network_level) <- network_labels

partialF <- covstatis_res$res4Splu$PartialF

for(i in 1:length(ids)){
  
  ### Grab all the partialF values associated with this subject for LV1
  this_lv1 <- partialF[,1,grep(paste0(ids[i], "_*"),dimnames(partialF)[[3]])]
  ## Transform the node-level partialF to network-level partialF for LV1
  this_lv1_network<-t(apply(makeNominalData(as.matrix(atlas_labels$Network)),2,function(x){x/sum(x)})) %*% 
    as.matrix(this_lv1)
  
  ### Grab all the partialF values associated with this P for LV2
  this_lv2 <- partialF[,2,grep(paste0(ids[i], "_*"),dimnames(partialF)[[3]])]
  ## Transform the node-level partialF to network-level partialF for LV2
  this_lv2_network<-t(apply(makeNominalData(as.matrix(atlas_labels$Network)),2,function(x){x/sum(x)})) %*% 
    as.matrix(this_lv2)
  
  ## Loop through each network, get the LV1 and LV2 points, and compute the area of the hull around the points
  for(n in 1:length(network_labels)){
    hull_pts <- chull(this_lv1_network[n,], this_lv2_network[n,]) #here you can play with the flag "percentage" and include either all points (like done here) or e.g., 95% of them in which case you'd write "percentage=0.95"
    this_hull_coords <- cbind(this_lv1_network[n,hull_pts],this_lv2_network[n,hull_pts] )
    this_poly_area <- Polygon(this_hull_coords, hole=F)@area
    task_diff_network_level[i,n] <- this_poly_area
    
  }
}

#print(task_diff_network_level) #you can go ahead and save this output and relate it to e.g., behavior
#### Eg lets see individual sub-network (DMN A) task differentiation scores and how they change with age
plot(x = demog_in$Age, y = (task_diff_network_level$DMN.A),
     xlab='Age', ylab = 'Task Differentiation', main='Default A')
```